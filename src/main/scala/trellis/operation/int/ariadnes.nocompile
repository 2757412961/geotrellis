package trellis.operation

/// 
/// Azavea Research Labs Cost-Distance algorithm, affectionately known
/// as "The Ariadnes Algorithm".
/// 
/// based on dzwarg's c# port & Tomlin's Python 

case class Popper(pV:Int, pH:Int, neighborV:Int, direction:Int)

/// <summary>
/// A static class that computes a cost-distance array.  This class has only one
/// method, and that is the spreading algorithm.
/// </summary>
class Spreader {
  /// The Heart of Ariadnes, in the form of the Spread function. This method takes
  /// a set of rasters, and computes the cost-distance to the target raster. All raster 
  /// layers must have the same dimensions.

  /// <param name="targetArray">The target array. Target cells have values in them,
  /// and the cost-distance will be computed to the cells that have no values.</param>
  /// <param name="frictionArray">The friction array. 0 and no data are treated the same.</param>
  /// <param name="elevationArray">The elevation array. To neglect elevation, use an 
  /// array full of 1's..</param>
  /// <param name="width">The width of the input rasters.</param>
  /// <param name="height">The height of the input rasters.</param>
  /// <param name="distance">The distance to compute until. If the distance exceeds the
  /// cost to the farthest pixel, the algorithm will compute the cost to all pixels. If the
  /// distance is less than the cost to the farthest pixel, the algorithm will compute all
  /// costs less than the distance, and quit early.</param>
  /// <param name="cellWidth">The width of a single cell in the rasters, in geographical units.</param>
  /// <param name="cancelled">A delegate that can be called to determine if the algorithm
  /// should cancel processing.</param>
  /// <returns></returns>

  /* all float[][] become single dimensional arrays */
    def Spread( height:Int, width:Int, target:DoubleRaster, friction:DoubleRaster, 
      elevation:DoubleRaster, maxDistance:Int, cellWidth:Double): DoubleRaster = {

      // Initialize values
      val size = width * height

      val output   = Array.ofDim[Double](width * height)
      val vMatrix  = Array.ofDim[Double](width * height)
      val hMatrix  = Array.ofDim[Double](width * height)

      val resolution:Double = cellWidth   // Grid cell width in geographical units
      val elevationAmplification:Int = 13 // Amplify elevation by this much
      var run:Double = 0.0                // Number of geographical units between centers of orthogonally or diagonally adjacent cells
      var friction:Double = 0.0           // Travelcost distance centers of orthogonally or diagonally adjacent cells
      var AddedCost:Double = 1.0;         // Slope-weighted travelcost distance centers of orthogonally or diagonally adjacent cells
      var Reach:Double = 0.0              // Inclined travelcost distance centers of orthogonally or diagonally adjacent cells
      var NeighborV:Double = 0.0          // Vertical component of a neighbor's incoming angle
      var NeighborH:Double = 0.0          // Horizontal component of a neighbor's incoming angle

      // The c# refers to NaN -- we'll use 'NODATA' value
      var NO_DATA = -1

      // python section: INITIALIZE SOME ARRAYS AND LOAD THE POPPER LIST WITH TARGET CELLS

      // Vertical offsets for a popper's neighbors
      val RowShift = Array(-1, 0, 1, 0, -1, -1, 1, 1)

      // Horizontal offsets for a popper's neighbors
      val ColumnShift = Array(0, 1, 0, -1, -1, 1, 1, -1)

      val CompassCode = Array(32, 64, 128, 16, 0, 1, 8, 4, 2)
      val PopperCount = 0
    
      // a "popper" is a tuple of the form (distance,x,y)
      // which indicates work to be done -- a cell that must be processed.

      // we store the cells in a priority queue because we want to keep them
      // sorted so that we can handle low distance cells before high distance cells

      // sort by first integer in integer 3-tuple, lowest first
      def PopperOrdering = new Ordering[(Int,Int,Int)] { 
        def compare(a: (Int,Int,Int), b: (Int,Int,Int)) = - Ordering[Int].compare(a._1,b._1)  

      }
      val poppers = new PriortyQueue[(Int,Int,Int)]()(PopperOrdering)

      for (y <- 0 until height) {
        for (x <- 0 until width) {
          if (friction.get(x, y) < 1) friction.set(x, y, 1)
          val initialDistance = target.get(x,y)
          if (initialDistance >= 0) { // target cell w/ 'headstart' (initial distance value)
            poppers += ((initialDistance, y, x))
          } else {
            poppers += ((maxDistance, y, x))
          }
        }
      }

      // python comment: LOOP THROUGH THE POPPER LIST
      var p = poppers.dequeue 

      while (p._1 < maxDistance) { // stop when accumulated travelcost is > maxDistance
        val pcost = p._1 // accumulated travelcost distance of this "popper" 
        val py  = p._2
        val px  = p._3

        val pindex = py * width + pxheight 

        // Incremental travelcost friction of the current popper
        val pfriction = friction.get(px,py)

        // Vertical & Horizontal components of the popper's incoming angle
        val pV = vMatrix(pindex)
        val pH = hMatrix(pindex)


        // python comment: LOOP THROUGH A GIVEN POPPER'S NEIGHBORS

        // Establish popper's neighborhood without going beyond the edge
        val top    = math.max(py-1, 0) 
        val bottom = math.min(py+1, height-1) 
        val left   = math.max(px-1, 0)
        val right  = math.min(px+1, width-1)

        for (y <- top until bottom + 1 ) {
          neighborV = py - y
          for (x <- left until right + 1 ) {
            if (x != px && y != py) { // skip neighborhood center
              var index = y * width + x
              neighborH = x - px
              
              val adjacent = if (y == py || x == px)

              val horizontal = if adjacent 1.0 else math.sqrt(2) 
              val run = resolution * horizontal
              val frictionDivisor = if adjacent 2 else math.sqrt(2)
              val friction = (pFriction + friction.get(x,y)) / frictionDivisor


              // python: USE THE 3D SURFACE TO ACHIEVE PLUME-LIKE DISSIPATION OF DISTANCE VALUES
              //         IN AN MANNER THAT I EXPECT TO REFINE FURTHER BUT WILL LEAVE AS IS FOR NOW

              val rise = (elevation.get(x,y) - elevation.get(px,py)) * elevationAmplification 
              val tangent = rise / run
              val reach = run + (run * tangent)
              val radians = math.atan2(rise,run)
              val reach = reach / math.cos(radians)
              val addedCost = friction * (reach / run)

              // python:--  CALCULATE NEIGHBOR'S N-NE-E-SE-S-SW-W-NW BEARING
              val direction = CompassCode(3 * (y + 1 - py)) + x + 1 - px)

              // python: CALCULATE NEIGHBOR'S ACCUMULATED TRAVEL COST DISTANCE WITH ARIADNE COMPENSATION

              val distance = PopperDistaince + AddedCost

              var turnWeight =(math.sqrt(math.pow((pV+neighborV),2)+math.pow((pH+neighborH),2)))-(math.sqrt(math.pow(pV,2)+math.pow(pH,2)))

              turnWeight = turnWeight / math.sqrt(math.pow(neighborV,2)+math.pow(neighborH,2)) 

              turnWeight = if (turnWeight < 0.82) 1.0 else turnWeight
              distance = if (popperDistance != 0.0) popperDistance + (addedCost + turnWeight) else distance

              // if neighbor's calculated distance does not exceed an earlier one ...
              if (distance < output(index)) {
                // REMEMBER THE HORIZONTAL AND VERTICAL COMPONENTS OF THE NEIGHBOR'S INCOMING ANGLE
                vMatrix(index) = pV + neighborV
                hMatrix(index) = pH + neighborH 

                // IDENTIFY THE PIVOT CELL ASSOCIATED WITH THIS NEIGHBOR

                pivotY = py
                pivotX = px 
                
                var (pivotX, pivotY) = (Ordering.compare(pV,0), Ordering.compare(pH,0), neighborH) match {
                  // Heading Northward then turning
                  case ( 1,  0, -1, _) => (px-1,py) // Westerly, pivot west of popper
                  case ( 1,  0,  1, _) => (px+1,py) // Easterly, pivot east
                  // Heading Southward then turning
                  case (-1,  0,  1, _) => (px+1,py) // Easterly, pivot east
                  case (-1,  0, -1, _) => (px-1,py) // Westerly, pivot west
                  // Heading Eastward then turning
                  case ( 0,  1,  1, _) => (px, py+1) // Northerly, pivot north
                  case ( 0,  1, -1, _) => (px, py-1) // Southerly, pivot south
                  // Heading Westerward then turning
                  case ( 0, -1, -1, _) => (px, py+1) // Southerly, pivot south
                  case ( 0, -1,  1, _) => (px, py-1) // Northerly, pivot north
                  // Heading Northeasterly then turning
                  case ( 1,  1,  _, 64) => (px-1, py) // North, pivot west
                  case ( 1,  1,  _,  1) => (px, py+1) // East, pivot south
                  case ( 1,  1,  _,  128) if pV/pH < 1 => (px, py-1) // left to Northeast, pivot north
                  case ( 1,  1,  _,  128) if pV/pH > 1 => (px+1, py) // right to Northeast, pivot east 
                  // Heading Southeasterly then turning
                  case (-1,  1,  _,  1) => (px, py-1) // East, pivot north
                  case (-1,  1,  _,  4) => (px-1, py) // South, pivot west 
                  case (-1,  1,  _,  2) if pV/pH < -1 => (px+1, py) // left to southeast, pivot east
                  case (-1,  1,  _,  2) if pV/pH > 1 => (px, py+1) // right to southeast, pivot south
                  // Heading Southwesterly then turning
                  case (-1, -1,  _,  4) => (px+1, py) // South, pivot east
                  case (-1, -1,  _,  16) => (px, py-1) // West, pivot north 
                  case (-1, -1,  _,  8) if pV/pH < -1 => (px, py+1) // left to southwest, pivot south
                  case (-1, -1,  _,  8) if pV/pH > 1 => (px-1, py) // right to southwest, pivot west
                  // Heading Southwesterly then turning
                  case ( 1, -1,  _,  16) => (px, py+1) // West, pivot south
                  case ( 1, -1,  _,  64) => (px+1, py) // North, pivot east
                  case ( 1, -1,  _,  32) if pV/pH < -1 => (px-1, py) // left to northwest, pivot west
                  case ( 1, -1,  _,  32) if pV/pH > 1 => (px, py-1) // right to northwest, pivot north
                }


                //  IF PIVOTING, CANCEL THE ARIADNE EFFECT
                if (friction.get(pivotX,pivotY) > pFriction || friction(x,y) != friction(px,py) ) {
                  vMatrix(index) = neighborV
                  hMatrix(index) = neighborH
                  distance       = pDistance + addedCost
                }

                if (distance != output(index)) {
                  output(index) = distance

                  //add this neighbor to popper list
                  q += ((distance, y, x))
                }
              } 
            }  
          }
        }
        output
      }            
    }
  }
}
